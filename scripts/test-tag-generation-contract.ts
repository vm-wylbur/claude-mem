#!/usr/bin/env npx tsx
// TDD Contract Tests for Tag Generation System
// These tests DEFINE what "working tag generation" means and catch constraint issues

import { initializeHasher, generateTagHash, isValidTagName } from '../src/utils/hash.js';
import { getDatabaseConfigToml } from '../src/config-toml.js';
import { PostgresAdapter } from '../src/db/adapters/postgres.js';
import { DatabaseService } from '../src/db/service.js';

interface TestResult {
  name: string;
  passed: boolean;
  error?: string;
}

// Import the tag generation function we need to test
// We'll need to extract this from the inline function in index.ts
async function generateSmartTags(content: string, type: string): Promise<string[]> {
  const tags: string[] = [];
  const lowerContent = content.toLowerCase();
  
  // Add type-based tag
  tags.push(type);
  
  // Technology tags
  const techPatterns = {
    'typescript': /\b(typescript|\.ts|\.tsx)\b/,
    'javascript': /\b(javascript|\.js|\.jsx|node\.js)\b/,
    'react': /\b(react|jsx|component|hook|useState|useEffect)\b/,
    'database': /\b(database|db|sql|postgres|sqlite|query|table)\b/,
    'api': /\b(api|endpoint|rest|graphql|http|request|response)\b/,
    'testing': /\b(test|spec|jest|mocha|cypress|unit test|integration)\b/,
    'git': /\b(git|commit|branch|merge|pull request|pr)\b/,
    'docker': /\b(docker|container|dockerfile|image)\b/,
    'mcp': /\b(mcp|model context protocol|tool|server)\b/
  };
  
  // Status/action tags
  const actionPatterns = {
    'bugfix': /\b(fix|bug|error|issue|problem|broken)\b/,
    'feature': /\b(new feature|add|implement|create|build)\b/,
    'refactor': /\b(refactor|cleanup|reorganize|improve)\b/,
    'performance': /\b(performance|optimize|speed|slow|fast)\b/,
    'security': /\b(security|auth|permission|vulnerability)\b/,
    'documentation': /\b(document|readme|comment|explain)\b/
  };
  
  // Add matching tech tags
  for (const [tag, pattern] of Object.entries(techPatterns)) {
    if (pattern.test(lowerContent)) {
      tags.push(tag);
    }
  }
  
  // Add matching action tags  
  for (const [tag, pattern] of Object.entries(actionPatterns)) {
    if (pattern.test(lowerContent)) {
      tags.push(tag);
    }
  }
  
  // Filter out invalid tag names before returning
  const { isValidTagName } = await import('../src/utils/hash.js');
  const validTags = tags.filter(tag => isValidTagName(tag));
  
  // Limit to most relevant tags
  return [...new Set(validTags)].slice(0, 6);
}

class TagGenerationContractTester {
  private adapter: PostgresAdapter | null = null;
  private service: DatabaseService | null = null;
  private results: TestResult[] = [];
  private testMemoryIds: string[] = [];

  async runAllTests(): Promise<void> {
    console.error('üß™ Tag Generation Contract Tests (TDD)');
    console.error('=======================================\n');

    try {
      await this.setup();
      
      // Test 1: Tag name validation
      await this.testTagNameValidation();
      
      // Test 2: Auto-generated tag validation
      await this.testAutoGeneratedTags();
      
      // Test 3: Problematic tag patterns
      await this.testProblematicTagPatterns();
      
      // Test 4: Database tag insertion
      await this.testDatabaseTagInsertion();
      
      await this.cleanup();
      this.printResults();
      
    } catch (error) {
      console.error('üí• Tag generation test setup failed:', error);
      process.exit(1);
    }
  }

  private async setup(): Promise<void> {
    console.error('üîß Setting up tag generation test environment...');
    
    await initializeHasher();
    
    // Use TOML config
    const config = await getDatabaseConfigToml();
    
    if (config.type !== 'postgresql') {
      throw new Error('Tag generation tests require PostgreSQL configuration');
    }
    
    this.adapter = new PostgresAdapter(config);
    await this.adapter.connect();
    this.service = new DatabaseService(this.adapter);
    await this.service.initialize();
    
    console.error('‚úÖ Tag generation test environment ready\n');
  }

  private async cleanup(): Promise<void> {
    // Clean up test memories
    if (this.testMemoryIds.length > 0) {
      console.error(`üßπ Cleaning up ${this.testMemoryIds.length} test memories...`);
      // Note: We'll implement cleanup if needed
    }
    
    if (this.adapter) {
      await this.adapter.disconnect();
    }
  }

  private async testTagNameValidation(): Promise<void> {
    console.error('üìã Testing tag name validation...');
    
    const tests = [
      {
        name: 'Valid tag names should pass validation',
        test: () => {
          const validTags = ['typescript', 'database', 'api', 'code', 'testing'];
          validTags.forEach(tag => {
            if (!isValidTagName(tag)) {
              throw new Error(`Valid tag rejected: ${tag}`);
            }
          });
        }
      },
      {
        name: 'Problematic tag names should be caught',
        test: () => {
          const problematicTags = ['bug-fix', 'very-long-tag-name-that-might-exceed-limits', ''];
          const expectedFailures = ['bug-fix', ''];
          
          problematicTags.forEach(tag => {
            const isValid = isValidTagName(tag);
            if (expectedFailures.includes(tag) && isValid) {
              throw new Error(`Problematic tag should be invalid: ${tag}`);
            }
            console.error(`  Tag "${tag}": ${isValid ? 'valid' : 'invalid'}`);
          });
        }
      }
    ];

    for (const { name, test } of tests) {
      try {
        await test();
        this.results.push({ name, passed: true });
      } catch (error) {
        this.results.push({ 
          name, 
          passed: false, 
          error: error instanceof Error ? error.message : String(error)
        });
      }
    }
  }

  private async testAutoGeneratedTags(): Promise<void> {
    console.error('üìã Testing auto-generated tag patterns...');
    
    const tests = [
      {
        name: 'TypeScript content should generate typescript tag',
        test: async () => {
          const content = 'TEST-TAG-GENERATION: Working with TypeScript interfaces and .ts files';
          const tags = await generateSmartTags(content, 'code');
          
          if (!tags.includes('typescript')) {
            throw new Error(`Expected 'typescript' tag, got: ${tags.join(', ')}`);
          }
          console.error(`  ‚úì Generated tags: ${tags.join(', ')}`);
        }
      },
      {
        name: 'Bug fix content should generate bug-fix tag',
        test: async () => {
          const content = 'TEST-TAG-GENERATION: Fix bug in error handling';
          const tags = await generateSmartTags(content, 'code');
          
          console.error(`  Generated tags: ${tags.join(', ')}`);
          if (tags.includes('bug-fix')) {
            throw new Error(`Tag 'bug-fix' contains hyphen - this may cause database constraint issues`);
          }
        }
      },
      {
        name: 'Database content should generate relevant tags',
        test: async () => {
          const content = 'TEST-TAG-GENERATION: Database query optimization for PostgreSQL';
          const tags = await generateSmartTags(content, 'code');
          
          const expectedTags = ['database', 'performance'];
          expectedTags.forEach(expectedTag => {
            if (!tags.includes(expectedTag)) {
              console.error(`  ‚ö†Ô∏è  Missing expected tag: ${expectedTag}`);
            }
          });
          console.error(`  ‚úì Generated tags: ${tags.join(', ')}`);
        }
      }
    ];

    for (const { name, test } of tests) {
      try {
        await test();
        this.results.push({ name, passed: true });
      } catch (error) {
        this.results.push({ 
          name, 
          passed: false, 
          error: error instanceof Error ? error.message : String(error)
        });
      }
    }
  }

  private async testProblematicTagPatterns(): Promise<void> {
    console.error('üìã Testing potentially problematic tag patterns...');
    
    const tests = [
      {
        name: 'Tags with hyphens should be identified as problematic',
        test: async () => {
          const content = 'TEST-TAG-GENERATION: Fix bug in API endpoint';
          const tags = await generateSmartTags(content, 'code');
          
          const hyphenatedTags = tags.filter(tag => tag.includes('-'));
          if (hyphenatedTags.length > 0) {
            throw new Error(`Hyphenated tags detected (may cause DB issues): ${hyphenatedTags.join(', ')}`);
          }
        }
      },
      {
        name: 'Tag generation should respect database constraints',
        test: async () => {
          const content = 'TEST-TAG-GENERATION: Very long content with many technical terms like TypeScript JavaScript React Database API Testing Git Docker MCP performance security';
          const tags = await generateSmartTags(content, 'code');
          
          // Check tag count limit
          if (tags.length > 6) {
            throw new Error(`Too many tags generated: ${tags.length} (limit: 6)`);
          }
          
          // Check tag name lengths
          tags.forEach(tag => {
            if (tag.length > 100) {
              throw new Error(`Tag too long: "${tag}" (${tag.length} chars)`);
            }
          });
          
          console.error(`  ‚úì Generated ${tags.length} tags within limits: ${tags.join(', ')}`);
        }
      }
    ];

    for (const { name, test } of tests) {
      try {
        await test();
        this.results.push({ name, passed: true });
      } catch (error) {
        this.results.push({ 
          name, 
          passed: false, 
          error: error instanceof Error ? error.message : String(error)
        });
      }
    }
  }

  private async testDatabaseTagInsertion(): Promise<void> {
    console.error('üìã Testing database tag insertion...');
    
    const tests = [
      {
        name: 'Simple valid tags should insert successfully',
        test: async () => {
          if (!this.service) throw new Error('Service not initialized');
          
          const content = 'TEST-TAG-GENERATION: Simple database test';
          const memoryId = await this.service.storeDevMemory(
            content,
            'code',
            { status: 'test', date: new Date().toISOString() }
          );
          
          this.testMemoryIds.push(memoryId);
          
          // Try adding simple tags
          const simpleTags = ['test', 'database', 'simple'];
          await this.service.addMemoryTags(memoryId, simpleTags);
          
          console.error(`  ‚úì Successfully added tags: ${simpleTags.join(', ')}`);
        }
      },
      {
        name: 'Auto-generated tags should insert without constraint errors',
        test: async () => {
          if (!this.service) throw new Error('Service not initialized');
          
          const content = 'TEST-TAG-GENERATION: TypeScript bug fix for API endpoint';
          const autoTags = await generateSmartTags(content, 'code');
          
          console.error(`  Auto-generated tags: ${autoTags.join(', ')}`);
          
          const memoryId = await this.service.storeDevMemory(
            content,
            'code',
            { status: 'test', date: new Date().toISOString() }
          );
          
          this.testMemoryIds.push(memoryId);
          
          // This is where the constraint error should occur
          await this.service.addMemoryTags(memoryId, autoTags);
          
          console.error(`  ‚úì Successfully added auto-generated tags`);
        }
      }
    ];

    for (const { name, test } of tests) {
      try {
        await test();
        this.results.push({ name, passed: true });
      } catch (error) {
        this.results.push({ 
          name, 
          passed: false, 
          error: error instanceof Error ? error.message : String(error)
        });
      }
    }
  }

  private printResults(): void {
    console.error('\nüìä Tag Generation Contract Test Results:');
    console.error('==========================================');
    
    let passed = 0;
    let total = this.results.length;
    
    this.results.forEach(result => {
      const status = result.passed ? '‚úÖ' : '‚ùå';
      console.error(`${status} ${result.name}`);
      if (!result.passed && result.error) {
        console.error(`   Error: ${result.error}`);
      }
      if (result.passed) passed++;
    });
    
    console.error(`\nüìà Contract Test Summary: ${passed}/${total} tests passed`);
    
    if (passed === total) {
      console.error('\nüéâ All tag generation tests passed!');
      console.error('‚úÖ Tag validation working correctly');
      console.error('‚úÖ Auto-generated tags functional');
      console.error('‚úÖ Database insertion working');
      process.exit(0);
    } else {
      console.error('\n‚ùå Tag generation issues detected');
      console.error('üîß Fix tag generation and database constraints before proceeding');
      
      if (this.testMemoryIds.length > 0) {
        console.error(`\nüßπ Test cleanup: ${this.testMemoryIds.length} test memories created`);
        console.error('üí° To clean up: DELETE FROM memories WHERE content LIKE \'TEST-TAG-GENERATION:%\'');
      }
      
      process.exit(1);
    }
  }
}

async function main() {
  const tester = new TagGenerationContractTester();
  await tester.runAllTests();
}

main().catch(error => {
  console.error('üí• Tag generation tests failed to run:', error);
  process.exit(1);
});