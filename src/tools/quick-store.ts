// TDD Phase 2: Quick Store Tool (GREEN phase implementation)
// Author: PB and Claude
// Date: 2025-07-04

import { BaseMCPTool, MCPResponse } from './base-tool.js';
import { MemoryType } from '../db/service.js';
import { formatHashForDisplay } from '../utils/hash.js';

export interface QuickStoreParams {
  content: string;
  type?: 'conversation' | 'code' | 'decision' | 'reference';
  status?: string;
  tags?: string[];
}

export class QuickStoreTool extends BaseMCPTool<QuickStoreParams> {
  constructor(
    dbService: any,
    private storeMemoryWithTagsFunction: (content: string, type: MemoryType, metadata: any, tags?: string[]) => Promise<string>,
    private detectMemoryTypeFunction: (content: string) => MemoryType,
    private generateSmartTagsFunction: (content: string, type: MemoryType) => Promise<string[]>
  ) {
    super(dbService);
  }

  async handle(params: QuickStoreParams): Promise<MCPResponse> {
    try {
      const { content, type, status, tags = [] } = params;
      
      // Auto-detect memory type if not provided
      const detectedType = type || this.detectMemoryTypeFunction(content);
      
      // Generate smart tags
      const autoTags = await this.generateSmartTagsFunction(content, detectedType);
      
      // Combine auto-generated tags with user-provided ones
      const allTags = [...new Set([...autoTags, ...tags])];
      
      // Extract key decisions if this appears to be a decision
      let keyDecisions: string[] | undefined;
      if (detectedType === 'decision') {
        const decisionMatches = content.match(/(?:decided|chose|selected|picked|opted)\s+[^.!?]*[.!?]/gi);
        keyDecisions = decisionMatches?.map(d => d.trim()) || undefined;
      }
      
      // Use shared storage function
      const memoryId = await this.storeMemoryWithTagsFunction(content, detectedType, {
        implementation_status: status,
        key_decisions: keyDecisions,
        date: new Date().toISOString()
      }, allTags);

      return {
        content: [{
          type: 'text',
          text: JSON.stringify({
            success: true,
            memoryId: formatHashForDisplay(memoryId),
            detectedType: detectedType,
            autoDetected: !type,
            tags: allTags,
            autoGeneratedTags: autoTags.length,
            keyDecisions: keyDecisions
          }, null, 2)
        }]
      };
    } catch (error) {
      return this.handleError(error, 'quick-store');
    }
  }
}